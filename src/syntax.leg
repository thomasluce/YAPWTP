%{
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include "bstrlib.h"
#include "list.h"
#include "content.h"
#include "yapwtp.h"
#include "io.h"

#define YY_noDEBUG 1

#define PRESERVE_TEMPLATES 1

#define IMAGE_FRAME 1
#define IMAGE_THUMB ( 1 << 1 )
#define IMAGE_NOLINK ( 1 << 2 )
#define IMAGE_CUSTOMLINK ( 1 << 3 )
#define IMAGE_HAS_CAPTION ( 1 << 4 )
#define IMAGE_BORDER ( 1 << 5 )

#define TOC_NOTOC ( 1 << 1 )
#define TOC_FORCETOC ( 1 << 2 )
#define TOC_RELOC ( 1 << 3 )

#define YY_INPUT(buf, result, max_size) handle_input(buf, &result, max_size)

int current_header_level = 0;
int current_bullet_list_level;
int current_numbered_list_level;

int start_of_line = 1;
char protocol[5];

// Images
int image_attributes = 0;
bstring image_url;
bstring image_variables;
bstring image_link_url;
bstring image_caption;

// Links
bstring link_path;
bstring link_text;

// HTML tags
bstring tag_name = NULL;
bstring tag_attribute = NULL;
bstring tag_attributes_validated = NULL;
struct list tag_attributes_list;

// Tables
int tr_found = 0;

// ToC
int toc_attributes = 0;
struct list toc_list;

// Wikitext
int in_tag = 0;
bstring tag_content;
unsigned int tag_content_size = 2 * MBYTE;

// Templates
struct list template_list;
struct node *template_list_iter = NULL;

// General
bstring output_buffer = NULL;
bstring input_buffer = NULL;
long input_buffer_pos = 0;
bstring base_url;

// Render the ToC from a list, output to buffer
void assemble_toc(struct node *item, bstring toc_buffer) {
  if(!item) {
    printf("Bad list passed to assemble_toc\n");
    return;
  }

  struct node *next;
  int previous_level = item->level;
  int total_layers = 0;
  int i;
  bformata(toc_buffer, "%s", "<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Contents</div>\n<ol>\n");
  while(item != NULL) {
    next = item->next;

    // Layer the list deeper as necessary
    if(item->level > previous_level) {
      repeat_append(toc_buffer, ' ', (total_layers + 1) * 2);
      for(i = previous_level; i < item->level; i++) {
        bformata(toc_buffer, "%s", "<ol>\n");
        total_layers++;
      }
    } else if(item->level < previous_level) {
      for(i = previous_level; i > item->level; i--) {
        repeat_append(toc_buffer, ' ', (total_layers) * 2);
        bformata(toc_buffer, "%s", "</ol></li>\n");
        total_layers--;
      }
    }

    // Add the item
    if(item->name && item->content) {
      repeat_append(toc_buffer, ' ', (total_layers + 1) * 2);
      bformata(toc_buffer, "  <li><a href=\"#%s\">%s</a>", bdata(item->name), bdata(item->content));
      if(next && next->level > item->level) {
        bcatcstr(toc_buffer, "\n");
      } else {
        bcatcstr(toc_buffer, "</li>\n");
      }
    }
    previous_level = item->level;
    item = next;
  }

  // Clean up lists left open
  while(total_layers > 0) {
    bformata(toc_buffer, "%s", "</ol>\n");
    total_layers--;
  }
  bformata(toc_buffer, "%s", "</ol>\n</div>\n");
}

// Insert the ToC into the output buffer in place of the __TOC__ tag
void insert_reloc_toc(bstring toc_buffer) {
  bstring find = bfromcstr("__TOC__");
  if(bfindreplace(output_buffer, find, toc_buffer, 0) == BSTR_ERR) {
    printf("Error inserting toc_buffer into output_buffer\n");
  }
  bdestroy(find);
}

// Main ToC routine
void handle_toc(void) {
  if(toc_attributes & TOC_NOTOC) {
    return;
  }

  if((toc_list.size > 3) || (toc_attributes & TOC_FORCETOC)) {
    bstring toc_buffer = bfromcstr("");
    assemble_toc(toc_list.head->next, toc_buffer);

    if(toc_attributes & TOC_RELOC) {
      insert_reloc_toc(toc_buffer);
      bdestroy(toc_buffer);
      return;
    }

    if(binsert(output_buffer, 0, toc_buffer, ' ') != BSTR_OK) {
      printf("Error prepending toc_buffer to output_buffer\n");
    }
    bdestroy(toc_buffer);
  }
}

void open_tag(char *tag, char *args) {
  if(args) {
    bprintf("<%s %s>", tag, args);
  } else {
    bprintf("<%s>", tag);
  }

  in_tag = 1;
  if(tag_content) {
    btrunc(tag_content,0 );
  }
}

void close_tag(char *tag) {
  bprintf("</%s>", tag);
  in_tag = 0;
}

void append_to_tag_content(char *fmt, ...) {
  int ret;

  if(!in_tag) {
    bvformata(ret, output_buffer, fmt, fmt);
    return;
  }

  bvformata(ret, tag_content, fmt, fmt);
}

// Initialize variables used in html tag processing
void init_tag_vars(void) {
  btrunc(tag_name, 0);
  btrunc(tag_attribute, 0);
  btrunc(tag_attributes_validated, 0);
  if(tag_attributes_list.size > 0) {
    list_free(&tag_attributes_list);
    list_init(&tag_attributes_list);
  }
}

%}

# High-level
page =  pre_block | wikitext_line | wikitext
wikitext_line = paragraph | horizontal_line
wikitext = nowiki | html | table_of_contents | template | heading | indentation | list | formatting | image | link | table | anything_else | eol { append_to_tag_content("%c", '\n'); }

# Generally useful rules
eol = '\r'? '\n' { start_of_line = 1; }
eof = !.
space = [\t ]

# Headings
heading = heading_marker {
    char tag[4];
    bprintf("\n  ");
    sprintf(tag, "h%d", current_header_level);
    open_tag(tag, NULL);
  } space* heading_text heading_marker space* ( eol | eof )
  {
    brtrimws(tag_content);
    bstring tmp = bstrcpy(tag_content);
    strip_html_markup(tmp);
    urlencode(tmp);
    bprintf("<span class=\"editsection\">[<a href=\"edit\">edit</a>]</span><span class=\"mw-headline\" id=\"%s\">", bdata(tmp));
    bdestroy(tmp);

    bprintf("%s</span>", bdata(tag_content));
    char tag[4];
    sprintf(tag, "h%d", current_header_level);
    close_tag(tag);
    bprintf("\n");

    struct node *current = list_append_new(&toc_list);

    tmp = bstrcpy(tag_content);
    strip_html_markup(tmp);
    urlencode(tmp);
    bprintf("  <a name=\"%s\"></a>\n", bdata(tmp));
    bassign(current->name, tmp);

    bstring human_name = bstrcpy(tag_content);
    strip_tags(human_name);
    brtrimws(human_name);
    bassign(current->content, human_name);
    current->level = current_header_level;

    bdestroy(tmp);
    bdestroy(human_name);

    btrunc(tag_content, 0);
    current_header_level = 0;
  }
heading_text = < ( !heading_marker ( formatting | link | anything_else ) )* >
heading_marker = < '=' '='+ > { if(current_header_level == 0) current_header_level = (yyleng > 5) ? 5 : yyleng; }

# Paragraph
paragraph = wikitext eol eol { bprintf("</p>\n<p>"); }
horizontal_line = "----" ( eol | eof )  { bprintf("<hr/>\n"); }

# Indentation
indentation = &{ start_of_line } ':' { bprintf("&nbsp;&nbsp;"); } wikitext

# Lists
list = &{ start_of_line } ( bullet_list | numbered_list )
list_text = ( !eol ( < [*#:] > { bprintf("%s", yytext); } | wikitext ) )*

# Bullet list
bullet_list = { bprintf("<ul>"); } bullet_list_entry+ {
  while((current_bullet_list_level > 0) && current_bullet_list_level--) {
    bprintf("</ul>");
  }
}
bullet_list_entry = bullet space*  list_text ( eol | eof ) { bprintf("</li>"); }
bullet = < '*'+ > {
  while((current_bullet_list_level < yyleng) && current_bullet_list_level++) {
      bprintf("<ul>");
  }
  while((current_bullet_list_level > yyleng) && current_bullet_list_level--) {
      bprintf("</ul>");
  }
  current_bullet_list_level = yyleng;
  bprintf("<li>");
  start_of_line = 0;
}

# Numbered list
numbered_list = { bprintf("<ol>"); } numbered_list_entry+ { 
  while((current_numbered_list_level > 0) && current_numbered_list_level--) { 
    bprintf("</ol>"); 
  } 
}
numbered_list_entry = numbered space* list_text eol? { bprintf("</li>"); }
numbered = < '#'+ > {
  while((current_numbered_list_level < yyleng) && current_numbered_list_level++) {
      bprintf("<ol>");
  }
  while((current_numbered_list_level > yyleng) && current_numbered_list_level--) {
      bprintf("</ol>");
  }
  current_numbered_list_level = yyleng;
  bprintf("<li>");
  start_of_line = 0;
}

# Formatting
formatting = bold_italic | bold | italic
bold_italic = "'''''" { append_to_tag_content("<b><i>"); }( !"'''''" wikitext )* "'''''" { append_to_tag_content("</i></b>"); }
bold = "'''" { append_to_tag_content("<b>"); }( !"'''" wikitext )* "'''" { append_to_tag_content("</b>"); }
italic = "''" { append_to_tag_content("<i>"); }( !"''" wikitext )* "''" { append_to_tag_content("</i>"); }

# pre-formatted blocks
pre_block = &{ start_of_line } { bprintf("<pre>"); } pre_line+ { bprintf("</pre>"); }
pre_line = ' ' < ( !eol . )* ( eol | eof ) > { bprintf("%s", yytext); }
nowiki = nowiki_open < ( !nowiki_close . )* > {
  start_of_line = 0;
  bstring markup = bfromcstr(yytext);
  strip_tags(markup);
  append_to_tag_content("%s", bdata(markup));
  bdestroy(markup);
} nowiki_close
nowiki_open = nowiki_open_tag | html_pre_open | html_code_open
nowiki_close = nowiki_close_tag | html_pre_close | html_code_close
nowiki_open_tag = '<nowiki>' 
nowiki_close_tag = '</nowiki>' 
html_pre_open = ( '<pre' ( !'>' . )* '>' | '<PRE>' ) { append_to_tag_content("<pre>"); }
html_pre_close = ( '</pre>' | '</PRE>' ) { append_to_tag_content("</pre>"); }
html_code_open = ( '<code' ( !'>' . )* '>' | '<CODE>' ) { append_to_tag_content("<code>"); }
html_code_close = ( '</code>' | '</CODE>' ) { append_to_tag_content("</code>"); }

# Links
link = ( local_link | external_link ) { start_of_line = 0; }
local_link = link_open ':'? namespace? link_path rename? link_close blend {
  strip_html_markup(link_path);
  urlencode(link_path);
  remove_parentheticals(link_text);
  btrimws(link_text);
  append_to_tag_content("<a href=\"%s/%s\">%s</a>", bdata(base_url), bdata(link_path), bdata(link_text));
  btrunc(link_path, 0);
  btrunc(link_text, 0);
  }
namespace = < ( !':' !link_close . )* > ':' { bformata(link_path, "%s:", yytext); }
link_path = < ( !link_close !'|' . )* > { bcatcstr(link_path, yytext); bcatcstr(link_text, yytext); }
rename = '|' < ( !link_close . )* > { btrunc(link_text, 0); bcatcstr(link_text, yytext); }
blend = < ( !space !( '=' '='+ ) ![<'[{] !eol !eof . )* > { bcatcstr(link_text, yytext); }

external_link = named_link | unnamed_link | url
named_link = '[' !'javascript:' { append_to_tag_content("<a href=\""); } link_url { append_to_tag_content("\">");} ' '+ link_name + space* ']' { append_to_tag_content("</a>"); }
link_url = < ( !' ' !']' . )+ >  { append_to_tag_content(yytext); }
link_name = < ( !']' . )+ > { append_to_tag_content(yytext); }
unnamed_link = '[' !'javascript:' < ( !']' . )* > ']' { append_to_tag_content("<a href=\"%s\">%s</a>", yytext, yytext);}
url = < ( 'http' | 'https' | 'ftp' ) > { strcpy(protocol, yytext); } '://' < ( !eol !' ' . )* > { append_to_tag_content("<a href=\"%s://%s\">%s://%s</a>", protocol, yytext, protocol, yytext); }
link_open = '[['
link_close = ']]'

# Images
image = open_image { btrunc(image_variables, 0); } file_indicator arguments? image_caption? close_image {
  if(image_attributes & IMAGE_FRAME) {
    bprintf("<div class=\"thumb tright\"><div class=\"thumbinner\">");
  }

  if(!(image_attributes & IMAGE_NOLINK)) {
    if(image_attributes & IMAGE_CUSTOMLINK)
      bprintf("<a href=\"%s\" class=\"image\">", bdata(image_link_url));
    else
      if(image_attributes & IMAGE_HAS_CAPTION)
        bprintf("<a href=\"File:%s\" class=\"image\" title=\"%s\">", bdata(image_url), bdata(image_caption));
      else
        bprintf("<a href=\"File:%s\" class=\"image\">", bdata(image_url));
  }

  if(image_attributes & IMAGE_THUMB) {
    bprintf("<img src=\"%s\" width=\"220\" height=\"30\" class=\"thumbimage\"/>", bdata(image_url));
  } else if((image_attributes & IMAGE_FRAME) || (image_attributes & IMAGE_BORDER)) {
    bprintf("<img src=\"%s\" class=\"thumbimage\"/>", bdata(image_url));
  } else {
    bprintf("<img src=\"%s\" %s/>", bdata(image_url), bdata(image_variables));
  }
  if(!(image_attributes & IMAGE_NOLINK)) {
    bprintf("</a>");
  }

  if(image_attributes & IMAGE_FRAME) {
    bprintf("<div class=\"thumbcaption\">%s</div></div>", bdata(image_caption));
  }
}
open_image = '[[' space*
close_image = space* ']]'
file_indicator = ( 'File:' | 'Image:' ) < ( !'|' !close_image . )* > { bassignformat(image_url, "%s", yytext); }
arguments = '|' ( special_image_variables | generic_variable value ) arguments?
special_image_variables = image_type | float | image_link | image_border
image_type = frame | thumb
frame = 'frame' { image_attributes |= IMAGE_FRAME; }
thumb = ( 'thumbnail' | 'thumb' ) { image_attributes |= IMAGE_THUMB; }
float = < ( 'left' | 'right' | 'center' ) > {
  bformata(image_variables, " class=\"float%s\"", yytext);
} | 'none'
image_link = 'link=' < ( !'|' !close_image . )* > {
  if(strcmp(yytext, "") == 0) {
    image_attributes |= IMAGE_NOLINK;
  } else {
    image_attributes |= IMAGE_CUSTOMLINK;
    bassignformat(image_link_url, "%s", yytext);
  }
}
image_border = 'border' { image_attributes |= IMAGE_BORDER; }
generic_variable = < ( !'|' !'=' !close_image . )* > {
  bformata(image_variables, "%s", yytext);
}
value = '=' < ( !'|' !close_image . )* > {
  bformata(image_variables, "=\"%s\"", yytext);
}
image_caption = '|' < ( !close_image . )+ > {
  image_attributes |= IMAGE_HAS_CAPTION;
  bassignformat(image_caption, "%s", yytext);
}

# Tables
table = table_open eol* table_caption? ( table_row | table_headers | table_cell )* eol* table_close
table_specials = ( [|+}!] | '-' )
table_delims =  ( ( '|' table_specials ) | ( &{start_of_line} '!' ) | ( &{start_of_line} '|') )
table_open = '{|' space* < ( !table_delims !eol . )* > { 
  tr_found = 0; 
  bprintf("<table");
  if(yyleng > 0) { 
    bprintf(" %s>", yytext); 
  } else { 
    bprintf(">"); 
  }
}
table_caption = '|+' space* { bprintf("<caption>"); } ( !table_delims wikitext )* &table_delims { brtrimws(output_buffer); bprintf("</caption>"); }
table_row = row_open ( simple_row | complex_row )
row_open = '|-' space* { tr_found = 1; bprintf("<tr");  }
simple_row = [ \t]* eol { bprintf(">"); } ( table_headers | table_cell )* { bprintf("</tr>"); }
complex_row = < ( !eol . )* > eol { bprintf(" %s>", yytext); } ( table_headers | table_cell )* { bprintf("</tr>"); }

table_headers = {
  if(!tr_found) { bprintf("<tr>"); } 
} ( complex_header | simple_header )+ {
  if(!tr_found) { bprintf("</tr>"); } 
}
complex_header = &{start_of_line} '!' space* { bprintf("<th"); } (
 < ( !( space* '|') . )* > space* { bprintf(" %s>", yytext); } '|' space* ( !table_delims !eol wikitext )* ( &table_delims | eol )
 ) { bprintf("</th>"); }
simple_header = &{start_of_line} '!' space* { bprintf("<th>"); }
  ( !eol !table_delims wikitext )+ ( eol | &table_delims ) 
  { bprintf("</th>"); }

table_cell = ( sol_cell | inline_cell )
cell_attribute_list = ( ( cell_attribute | cell_junk ) space* )+ {
  list_iterate(tag_attributes_list.head->next, validate_tag_attributes);
  bprintf("%s>", bdata(tag_attributes_validated));
}
cell_attribute = cell_attribute_name '=' cell_attribute_value
cell_attribute_name = < ( !eol !table_delims !'=' . )+ > {
  btrunc(tag_attribute, 0);
  bcatcstr(tag_attribute, yytext);
}
cell_attribute_value = '"' < ( !table_delims !['"] . )+ > '"' {
  struct node *node = list_append_new(&tag_attributes_list);
  bconcat(node->name, tag_attribute);
  bcatcstr(node->content, yytext);
}
cell_junk = < ( !( &table_delims ) !eol !'|' . )+ >

# -- start of line cell
sol_cell = ( sol_cell_complex | sol_cell_simple )
sol_cell_open = &{start_of_line} '|' !table_specials { 
  init_tag_vars(); 
  bcatcstr(tag_name, "td");
  // TODO bare cells can end up with no tr when they don't have one explicitly in the wikitext
  bprintf("<td"); }
sol_cell_close = &table_delims { 
  brtrimws(output_buffer); 
  bprintf("</td>"); 
}
sol_cell_complex = sol_cell_open cell_attribute_list space* '|' !'|' space* ( !table_delims wikitext )* sol_cell_close 
sol_cell_simple  = sol_cell_open space* { bprintf(">"); } ( !table_delims wikitext )* sol_cell_close
# -- inline cell
inline_cell = '||' space* { bprintf("<td>"); } ( !table_delims wikitext )* &table_delims { brtrimws(output_buffer); bprintf("</td>"); }

table_close = '|}' { brtrimws(output_buffer); bprintf("</table>"); }

# Templates
template = template_open space* template_name template_content? template_close
template_open = '{{' { list_append_new(&template_list); }
template_name = < ( !template_close !'|' . )* > {
  bcatcstr(template_list.tail->name, yytext);
  brtrimws(template_list.tail->name);
}
template_content = '|' space* < ( !template_close . )+ > {
  bcatcstr(template_list.tail->content, yytext);
}
template_close = '}}' {
  start_of_line = 0;
  if(PRESERVE_TEMPLATES) {
    // Some bug in leg prevents using braces here or even in this comment
    bprintf("__%s_%ld__", bdata(template_list.tail->name), hash(bdata(template_list.tail->content)));
  }
}

# Table of Contents
table_of_contents = ( notoc | toc | forcetoc )
notoc = '__NOTOC__' { toc_attributes |= TOC_NOTOC; }
forcetoc = '__FORCETOC__' { toc_attributes |= TOC_FORCETOC; }
toc = '__TOC__' { toc_attributes |= TOC_RELOC; bprintf("__TOC__"); // pass-through for later replacement }

# HTML markup
html = tag_open tag tag_attributes_list? tag_close
tag_open = '<' { init_tag_vars(); }
tag = < '/'? ( !tag_close !space . )+ > { bcatcstr(tag_name, yytext); }
tag_attributes_list = ( space ( tag_attribute | tag_junk ) )+
tag_attribute = tag_attribute_name '=' tag_attribute_value
tag_attribute_name = < ( !'=' . )+ > {
  btrunc(tag_attribute, 0);
  bcatcstr(tag_attribute, yytext);
}
tag_attribute_value = '"' < ( !tag_close !['"] . )+ > '"' {
  struct node *node = list_append_new(&tag_attributes_list);
  bconcat(node->name, tag_attribute);
  bcatcstr(node->content, yytext);
}
tag_junk = < ( !tag_close . )+ >
tag_close = ( space* '/'? '>' ) {
  list_iterate(tag_attributes_list.head->next, validate_tag_attributes);

  btolower(tag_name);
  if(valid_html_tag(bdata(tag_name), tag_name->slen)) {
    bprintf("<%s%s>", bdata(tag_name), bdata(tag_attributes_validated));
  } else {
    strip_tags(tag_name);
    bprintf("&lt;%s&gt;", bdata(tag_name));
  }
  start_of_line = 0;
}

# Other shit
anything_else = < !eol . > { start_of_line = 0; append_to_tag_content(yytext); }


%%

bstring get_input_buffer(void) {
  return input_buffer;
}

bstring get_output_buffer(void) {
  return output_buffer;
}

char *get_output_buffer_cstr(void) {
  return bdata(output_buffer);
}

void set_base_url(char *str) {
  btrunc(base_url, 0);
  bcatcstr(base_url, str);
}

int get_template_count(void) {
  return template_list.size;
}

void reset_template_iter() {
  template_list_iter = template_list.head;
}

struct node *get_next_template(void) {
  if(!template_list_iter) {
    template_list_iter = template_list.head;
  }

  if(template_list_iter->next) {
    template_list_iter = template_list_iter->next;
    return template_list_iter;
  }

  return NULL;
}

void init(void) {
  current_header_level = 0;
  start_of_line = 1;
  image_attributes = 0;
  toc_attributes = 0;
  in_tag = 0;
  input_buffer_pos = 0;
  template_list_iter = NULL;
  tr_found = 0;

  list_init(&toc_list);
  list_init(&tag_attributes_list);
  list_init(&template_list);
  tag_content = bfromcstr("");
  balloc(tag_content, tag_content_size);

  image_variables = bfromcstr("");
  image_url = bfromcstr("");
  image_link_url = bfromcstr("");
  image_caption = bfromcstr("");

  link_path = bfromcstr("");
  link_text = bfromcstr("");

  output_buffer = bfromcstr("");
  input_buffer = bfromcstr("");
  balloc(output_buffer, 1 * MBYTE);

  base_url = bfromcstr("");

  tag_name = bfromcstr("");
  tag_attribute = bfromcstr("");
  tag_attributes_validated = bfromcstr("");
}

void cleanup(void) {
  bdestroy(tag_content);
  bdestroy(image_variables);
  bdestroy(image_url);
  bdestroy(image_link_url);
  bdestroy(image_caption);
  bdestroy(link_path);
  bdestroy(link_text);
  bdestroy(output_buffer);
  bdestroy(input_buffer);
  bdestroy(base_url);
  bdestroy(tag_name);
  bdestroy(tag_attribute);
  bdestroy(tag_attributes_validated);

  list_free(&toc_list);
  list_free(&tag_attributes_list);
  list_free(&template_list);

  // Clean up after leg...
  free(yybuf);
  free(yytext);
  free(yythunks);
  free(yyvals);
  yybuflen = 0;
}

void parse() {
  bprintf("<p>");
  while(yyparse()) {}
  bprintf("</p>");
  handle_toc();
}

